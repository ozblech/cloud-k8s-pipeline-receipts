name: CD - Deploy with kubectl

permissions:
  id-token: write  # Required for OIDC
  contents: read   # Required for actions/checkout

on:
  workflow_call:
    inputs:
      image_tag:
        required: true
        type: string

env:
  IMAGE_REPO: ${{ vars.IMAGE_REPO }}              # e.g., ozblech/receipts-api
  DEPLOYMENT_NAME: ${{ vars.DEPLOYMENT_NAME }}    # e.g., receipts-api
  AWS_REGION: ${{ secrets.AWS_REGION }}
  IMAGE_TAG: ${{ inputs.image_tag }}  # e.g., a1b2c3d

jobs:
  deploy:
    name: Deploy to EC2 Minikube
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code # for using actions
        uses: actions/checkout@v4

      - name: Fetch EC2 public IP
        id: fetch-minikube-ec2-ip
        uses: ./.github/actions/fetch-ec2-public-ip
        with:
          tag_name: ${{ vars.MINIKUBE_EC2_TAG_NAME }}       # e.g., minikube-ec2
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          aws_region: ${{ env.AWS_REGION }}

      - name: Print DNS
        run: echo "DNS is ${{ steps.fetch-minikube-ec2-ip.outputs.public_dns }}"

      # - name: Generate values-secret.yaml from template
      #   run: |
      #     cd receipts_project/helm_chart/
      #     cp values-secret.template.yaml values-secret.yaml
      #     sed -i "s|__DB_USER__|${{ secrets.DB_USER }}|g" values-secret.yaml
      #     sed -i "s|__DB_PASSWORD__|${{ secrets.DB_PASSWORD }}|g" values-secret.yaml
      #     sed -i "s|__S3_BUCKET__|${{ secrets.S3_BUCKET_NAME }}|g" values-secret.yaml
      #     sed -i "s|__S3_REGION__|${{ secrets.AWS_REGION }}|g" values-secret.yaml
      #     sed -i "s|__DB_CONNECTION_STRING__|${{ secrets.DB_CONNECTION_STRING }}|g" values-secret.yaml
      #     sed -i "s|__AWS_ACCESS_KEY_ID__|${{ secrets.AWS_ACCESS_KEY_ID }}|g" values-secret.yaml
      #     sed -i "s|__AWS_SECRET_ACCESS_KEY__|${{ secrets.AWS_SECRET_ACCESS_KEY }}|g" values-secret.yaml

      - name: Tar and base64-encode Helm chart
        run: |
          tar -czf helm_chart.tar.gz -C receipts_project helm_chart
          base64 helm_chart.tar.gz > helm_chart.tar.gz.b64
          echo "Helm chart tar file created and encoded."
          ls -l helm_chart*

      - name: Upload Helm chart tarball to S3
        run: |
          aws s3 cp helm_chart.tar.gz s3://${{ secrets.S3_BUCKET_NAME }}/helm_chart.tar.gz

      - name: Create JSON command file for copying Helm chart tar file
        run: |
          COMMANDS_JSON=$(jq -n \
            --arg bucket "${{ secrets.S3_BUCKET_NAME }}" \
            '{
              commands: [
                "echo \"Downloading Helm chart from S3...\"",
                "aws s3 cp s3://\($bucket)/helm_chart.tar.gz /tmp/helm_chart.tar.gz",
                "mkdir -p /helm_chart/",
                "tar -xzvf /tmp/helm_chart.tar.gz -C /helm_chart/"
              ]
            }')

          echo "$COMMANDS_JSON" > copy-helm-chart.json
          cat copy-helm-chart.json

      - name: Run SSM command to copy Helm chart tar file from s3 to EC2
        id: run-ssm-copy-helm-chart
        uses: ./.github/actions/ssm
        with:
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          instance_id: ${{ steps.fetch-minikube-ec2-ip.outputs.instance_id }}
          commands-file-name: copy-helm-chart.json
          aws_region: ${{ env.AWS_REGION }}

      - name: Create JSON command file for deployment + remove old images
        run: |
          IMAGE_TAG="${{ env.IMAGE_TAG }}"
          DEPLOYMENT_NAME="${{ env.DEPLOYMENT_NAME }}"
          IMAGE_REPO="${{ env.IMAGE_REPO }}"
          KUBECONFIG_PATH="${{ vars.KUBECONFIG_PATH }}"

          echo "Fetching secrets from AWS Secrets Manager..."
          SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id receipts-app-secrets --query SecretString --output text)

          DB_USER=$(echo "$SECRET_JSON" | jq -r .db_user)
          DB_PASSWORD=$(echo "$SECRET_JSON" | jq -r .db_password)
          S3_BUCKET=$(echo "$SECRET_JSON" | jq -r .s3_bucket_name)
          S3_REGION=$(echo "$SECRET_JSON" | jq -r .s3_region)
          DB_CONN=$(echo "$SECRET_JSON" | jq -r .db_connection_string)
          AWS_KEY_ID=$(echo "$SECRET_JSON" | jq -r .aws_access_key_id)
          AWS_SECRET=$(echo "$SECRET_JSON" | jq -r .aws_secret_access_key)
          
          COMMANDS_JSON=$(jq -n \
            --arg image_tag "$IMAGE_TAG" \
            --arg deployment "$DEPLOYMENT_NAME" \
            --arg image_repo "$IMAGE_REPO" \
            --arg kubeconfig_path "$KUBECONFIG_PATH" \
            --arg db_user "$DB_USER" \
            --arg db_password "$DB_PASSWORD" \
            --arg s3_bucket "$S3_BUCKET" \
            --arg s3_region "$S3_REGION" \
            --arg db_conn "$DB_CONN" \
            --arg aws_key "$AWS_KEY_ID" \
            --arg aws_secret "$AWS_SECRET" \
            '{
              commands: [
                "export KUBECONFIG=\($kubeconfig_path)",
                "echo \"Getting secrets from AWS Secrets Manager...\"",
                
                "echo \"Deploying new Docker image...\"",
                "helm upgrade \($deployment) /helm_chart/helm_chart/ --install --namespace default --values /helm_chart/helm_chart/values.yaml +
                "--set secret.db_user=\($db_user) " +
                "--set secret.db_password=\($db_password) " +
                "--set secret.s3_bucket_name=\($s3_bucket) " +
                "--set secret.s3_region=\($s3_region) " +
                "--set secret.db_connection_string=\($db_conn) " +
                "--set secret.aws_access_key_id=\($aws_key) " +
                "--set secret.aws_secret_access_key=\($aws_secret) " +
                "--set image.repository=\($image_repo) --set image.tag=\($image_tag)",
                "kubectl rollout status deployment/\($deployment) -n default --timeout=60s || (echo \"Rollout failed\" && exit 1)",
                "kubectl label deployment/\($deployment) version=\($image_tag) --overwrite",
                "echo \"Removing secret values file...\"",
                "rm -f /helm_chart/helm_chart/values-secret.yaml",
                "echo \"Cleaning up old Docker images...\"",
                "runuser -l ec2-user -c \"minikube ssh -- docker system prune -a -f\""
              ]
            }')

          echo "$COMMANDS_JSON" > deploy-commands.json
          cat deploy-commands.json

      - name: Run SSM command using action
        id: run-ssm-command
        uses: ./.github/actions/ssm
        with:
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          instance_id: ${{ steps.fetch-minikube-ec2-ip.outputs.instance_id }}
          commands-file-name: deploy-commands.json
          aws_region: ${{ env.AWS_REGION }}


      # - name: Configure AWS Credentials
      #   uses: aws-actions/configure-aws-credentials@v3
      #   with:
      #     role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
      #     aws-region: ${{ secrets.AWS_REGION }}

      # - name: Deploy via SSM to EC2
      #   env:
      #     INSTANCE_ID: ${{ steps.fetch-minikube-ec2-ip.outputs.instance_id }}
      #     IMAGE_TAG: ${{ steps.extract-image-tag.outputs.current_image_tag }}
      #   run: |
      #     aws ssm send-command \
      #       --instance-ids $INSTANCE_ID \
      #       --document-name "AWS-RunShellScript" \
      #       --comment "Update Kubernetes deployment image" \
      #       --parameters commands=["export KUBECONFIG=/home/ec2-user/.kube/config","kubectl set image deployment/receipts-api receipts-api=ozblech/receipts-api:$IMAGE_TAG"] \
      #       --cloud-watch-output-config CloudWatchOutputEnabled=true \
      #       --output text